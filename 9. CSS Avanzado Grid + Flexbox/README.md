# CSS Avanzado: Grid + Flexbox y Arquitecturas

## Tabla de contenido
- [¬øQu√© es Flexbox?](#¬øQu√©-es-Flexbox?)
- [Terminolog√≠a Flexbox](#Terminolog√≠a-Flexbox)
- [Propiedades de Flexbox](#Propiedades-de-Flexbox)
    - [Propiedades para el flex-container o elemento padre](#Propiedades-para-el-flex-container-o-elemento-padre:)
        - [Activar Flexbox](#Activar-Flexbox)
        - [Cambiar la direcci√≥n del contenido](#Cambiar-la-direcci√≥n-del-contenido)
        - [Activar m√∫ltiples l√≠neas de contenido](#Activar-m√∫ltiples-l√≠neas-de-contenido)
        - [Alineaci√≥n en el eje principal (main-axis)](#Alineaci√≥n-en-el-eje-principal-(main-axis))
        - [Alineaci√≥n en el eje secundario (cross-axis) cuando no hay m√∫ltiples l√≠neas de contenido](#Alineaci√≥n-en-el-eje-secundario-(cross-axis)-cuando-no-hay-m√∫ltiples-l√≠neas-de-contenido)
        - [Alineaci√≥n en el eje secundario (cross-axis) cuando hay m√∫ltiples l√≠neas de contenido](#Alineaci√≥n-en-el-eje-secundario-(cross-axis)-cuando-hay-m√∫ltiples-l√≠neas-de-contenido)
    - [Propiedades para los flex-items o elemento hijos directos del flex-container](#Propiedades-para-los-flex-items-o-elemento-hijos-directos-del-flex-container:)
        - [Factor de encogimiento](#Factor-de-encogimiento)
        - [Factor de crecimiento](#Factor-de-crecimiento)
        - [Establecer la dimensi√≥n en el eje principal](#Establecer-la-dimensi√≥n-en-el-eje-principal)
        - [Shorthand Flex](#Shorthand-Flex)
        - [Alinear un flex-item en particular en el eje secundario (cross-axis)](#Alinear-un-flex-item-en-particular-en-el-eje-secundario-(cross-axis))
        - [Reescribir el orden en el que un elemento es dibujado por el navegador](#Reescribir-el-orden-en-el-que-un-elemento-es-dibujado-por-el-navegador)
- [Notas generales de los ejercicios de Flexbox](#Notas-generales-de-los-ejercicios-de-Flexbox)
- [¬øQu√© es CSS Grid Layout?](#¬øQu√©-es-CSS-Grid-Layout?)
- [Terminolog√≠a de CSS Grid Layout](#Terminolog√≠a-de-CSS-Grid-Layout)
- [Propiedades de CSS Grid Layout](#Propiedades-de-CSS-Grid-Layout)
    - [Para el grid-container (elemento padre)](#Para-el-grid-container-(elemento-padre):)
        - [Activar CSS Grid Layout](#Activar-CSS-Grid-Layout)
        - [Controlar el flujo de los elementos en el Grid Impl√≠cito](#Controlar-el-flujo-de-los-elementos-en-el-Grid-Impl√≠cito)
        - [Declarar filas en CSS Grid Layout](#Declarar-filas-en-CSS-Grid-Layout)
        - [Declarar columnas en CSS Grid Layout](#Declarar-columnas-en-CSS-Grid-Layout)
        - [Declararle nombre a las filas o columnas](#Declararle-nombre-a-las-filas-o-columnas)
        - [Nueva unidad de medida de CSS Grid Layout](#Nueva-unidad-de-medida-de-CSS-Grid-Layout)
        - [Funci√≥n repeat() de CSS Grid Layout](#Funci√≥n-repeat()-de-CSS-Grid-Layout)
        - [Funci√≥n minmax() de CSS Grid Layout](#Funci√≥n-minmax()-de-CSS-Grid-Layout)
        - [Espaciado en el Grid](#Espaciado-en-el-Grid)
        - [Alineaci√≥n de los grid-items](#Alineaci√≥n-de-los-grid-items)
        - [Alineaci√≥n del Grid dentro del grid-container en CSS Grid Layout](#Alineaci√≥n-del-Grid-dentro-del-grid-container-en-CSS-Grid-Layout)
    - [Propiedades de los grid-items (hijos directos del grid-container)](#Propiedades-de-los-grid-items-(hijos-directos-del-grid-container):)
        - [Posicionar un grid-items horizontalmente seg√∫n las grid-lines de las filas](#Posicionar-un-grid-items-horizontalmente-seg√∫n-las-grid-lines-de-las-filas)
        - [Posicionar un grid-item verticalmente seg√∫n las grid-lines de las columnas](#Posicionar-un-grid-item-verticalmente-seg√∫n-las-grid-lines-de-las-columnas)
        - [Shorthand para posicionar grid-items horizontal y verticalmente seg√∫n las grid-lines](#Shorthand-para-posicionar-grid-items-horizontal-y-verticalmente-seg√∫n-las-grid-lines)
        - [Alinear un grid-items en particular](#Alinear-un-grid-items-en-particular)
        - [Posicionar elementos con nombres de √°reas](#Posicionar-elementos-con-nombres-de-√°reas)
- [Notas generales de los ejercicios de CSS Grid Layout](#Notas-generales-de-los-ejercicios-de-CSS-Grid-Layout)
- [Arquitectura CSS](#Arquitectura-CSS)
- [¬øQu√© son los componentes?](#¬øQu√©-son-los-componentes?)
- [Patrones de dise√±o](#Patrones-de-dise√±o)
    - [¬øPor qu√© usar patrones en CSS?](#¬øPor-qu√©-usar-patrones-en-CSS?)
- [Gu√≠as de estilos](#Gu√≠as-de-estilos)
- [Tipos de Arquitecturas](#Tipos-de-Arquitecturas)
    - [SMACSS: Scalable and Modular Architecture for CSS](#SMACSS:-Scalable-and-Modular-Architecture-for-CSS)
    - [OOCSS: Object-Oriented CSS](#OOCSS:-Object-Oriented-CSS)
    - [ITCSS: Inverted Triangle Architecture for CSS](#ITCSS:-Inverted-Triangle-Architecture-for-CSS)
    - [Atomic Design](#Atomic-Design)
- [Tipos de Nomenclaturas](#Tipos-de-Nomenclaturas)
    - [BEM: Block Element Modifier](#BEM:-Block-Element-Modifier)
    - [SUIT CSS](#SUIT-CSS)
- [Contenido complementario](#Contenido-complementario)
    - [Manejo de tipograf√≠as](#Manejo-de-tipograf√≠as)
- [Link de inter√©s](#Link-de-inter√©s)


<div style="background:#f9fdc0;border-radius:5px;padding:10px 20px;color:#000">

### <span style="border-bottom: 1px solid #444; display: block; padding-bottom: 10px; margin-bottom: 20px;font-weight:bold;">Nota del Autor</span>

Aunque el presente curso sirvi√≥ para afianzar los conocimientos adquiridos en los cursos anteriores, **considero que no aporta nada nuevo** a los temas de CSS Grid Layout o de Flexbox. Los cuales seg√∫n mi opini√≥n: Flexbox qued√≥ bien explicado en el <a href="../8.%20CSS%20desde%20cero" style="color: inherit; text-decoration: underline">Curso de CSS desde cero</a> y con CSS Grid Layout **sigo recomendando** el <a href="../5.%20CSS%20Grid%20Layout" style="color: inherit; text-decoration: underline">Curso de CSS Grid Layout</a> dado que est√° mejor estructurado los temas y con explicaciones m√°s simples y entendibles.

Teniendo como fundamento lo anterior me tomar√© la libertad de no incluir ilustraciones de las propiedades como se ha venido haciendo en los res√∫menes anteriores.

**Recomiendo** este curso para tener una idea acerca de las arquitecturas y nomenclaturas de CSS.
</div>

## ¬øQu√© es Flexbox?
Es un m√≥dulo de CSS que permite crear layouts a trav√©s de un concepto de "cajas flexibles". Depende de dos elementos: un `flex-container` y los `flex-items`, es decir, de un contenedor padre a quien se le aplique la propiedad y sus respectivos hijos directos.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

## Terminolog√≠a Flexbox
1. `flex-container`: Es el contenedor que recibe la propiedad de `display: flex;`.

2. `flex-items`: Son los hijos directos del `flex-container` (los cuales podr√≠an ser tambi√©n pseudoelementos y textos).

3. `flex-line`: Son las l√≠neas que usa Flexbox para distribuir el contenido. Por defecto Flexbox posicionar√° el contenido en single-line (en una sola l√≠nea) debido al valor por defecto de su propiedad "`flex-wrap: nowrap`", al cambiar el valor de dicha propiedad a "`wrap`" se puede decir que es multi-line (multi l√≠nea) aunque **cada l√≠nea de contenido es independiente**.

    >Nota: Aunque se utilice el valor de "`wrap`" queda en evidencia que cada l√≠nea es independiente puesto que si se invierte la direcci√≥n del contenido no se hace de manera global, sino l√≠nea por l√≠nea. **Es por eso que se considera a Flexbox single-line**.

4. `axis` (ejes): Corresponde a los ejes de Flexbox, los cuales son:

    4.1 `main-axis`: Corresponde al eje principal el cual por defecto es horizontal y tiene una direcci√≥n de izquierda a derecha. Adem√°s es el encargado de determinar a qu√© valor corresponder√° el `flex-basis` dependiendo de la orientaci√≥n.

    4.2 `cross-axis`: Corresponde al eje secundario el cual por defecto es vertical y tiene una direcci√≥n de arriba hacia abajo.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

## Propiedades de Flexbox

### Propiedades para el `flex-container` o elemento padre:

- #### Activar Flexbox
    Se puede activar Flexbox con las siguientes propiedades:

    * `display: flex;` </br>
    Activa la propiedad de Flexbox, pero los elementos hermanos del `flex-container` lo identificar√°n como si fuera un elemento de bloque.

    * `display: inline-flex;` </br>
    Activa la propiedad de Flexbox, pero los elementos hermanos del `flex-container` lo identificar√°n como si fuera un elemento en l√≠nea.

    >Nota: En ambos casos el comportamiento por defecto es colocar todos los elementos uno despu√©s del otros (en una l√≠nea horizontal) y si los `flex-items` (hijos directos del `flex-container`) no tuvieran altura declarada los estirar√≠a hasta cubrir por completo el `cross axis`.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Cambiar la direcci√≥n del contenido
    Se puede cambiar la direcci√≥n en la cual se muestra el contenido con 4 valores diferentes, los cuales son:

    * `flex-direction: row;`</br>
    Es el valor por defecto. Coloca todos los `flex-items` en direcci√≥n horizontal con un sentido de izquierda a derecha.

    * `flex-direction: row-reverse;`</br>
    Coloca todos los `flex-items` en direcci√≥n horizontal con un sentido de derecha a izquierda.

    * `flex-direction: column;`</br>
    Apila todos los elementos en columnas, es decir, uno debajo del otro en sentido de arriba hacia abajo y de izquierda a derecha.

    * `flex-direction: column-reverse;`</br>
    Apila todos los elementos en columnas, es decir, uno debajo del otro pero en sentido de abajo hacia arriba y de izquierda a derecha.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Activar m√∫ltiples l√≠neas de contenido
    Es posible darse el caso que se tengan muchos elementos en un `flex-container` que se necesite que los mismos se distribuyan en varias `flex-lines`. Esto se hace con la siguiente propiedad:

    * `flex-wrap: nowrap;`</br>
    Es el valor por defecto. Indica que el contenido no salte de l√≠nea, es decir, todos los `flex-items` intentar√°n ocupar una `flex-line` sin importar que estos se redimensionen (encojan) para que esto ocurra.

    * `flex-wrap: wrap;`</br>
    Permite que existan saltos de l√≠nea en los `flex-items`, de tal forma que si el contenido no cabe en la `flex-line` donde se ubica, salte a otra.

    * `flex-wrap: wrap-reverse;`</br>
    Permite que exista saltos de l√≠nea en los `flex-items`, de tal forma que si el contenido no cabe en la `flex-line` donde se ubica, salte a otra pero en sentido inverso del `cross-axis`.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Alineaci√≥n en el eje principal (`main-axis`)
    Para alinear los elementos en el eje principal se utiliza la siguiente propiedad en conjunto con alguno de los siguientes valores:

    * `justify-content: flex-start;` </br>
    Es el valor por defecto, ubica a los `flex-items` al principio del `main-axis`.

    * `justify-content: flex-end;` </br>
    Ubica a los `flex-items` al final del `main-axis`.

    * `justify-content: center;` </br>
    Ubica a los `flex-items` al centro del `main-axis`.

    * `justify-content: space-between;` </br>
    Permite que los `flex-items` se posicionen ocupando todo el espacio sobrante disponible del `main-axis` dejando a los elementos internos con un espaciado a su alrededor y los elementos externos (los que est√°n a los bordes) sin espaciado externo, es decir, "pegados" a los bordes del `flex-container`.

    * `justify-content: space-around;` </br>
    Permite que los elementos se posicionen ocupando todo el espacio sobrante disponible del `main-axis` d√°ndole a todos los elementos un espaciado interno como externo.

    * `justify-content: space-evenly;` </br>
    Permite que los `flex-items` se posicionen ocupando todo el espacio sobrante disponible del `main-axis` d√°ndole a todos los elementos un espaciado interno como externo, haciendo que todos est√©n exactamente a la misma distancia uno del otro tanto los interno como los externos.

    A considerar:

    - Cabe destacar que los m√°rgenes en Flexbox se suman, es decir, no hay colapsado de m√°rgenes. Es por esto que los elementos internos posicionados con `justify-content: space-around;` tienen un mayor espaciado que los externos (los que est√°n a los bordes del `flex-container`).

    - Para que la propiedad `justify-content` tenga efecto con alguno de sus valores **debe existir un espaciado sobrante** en el `main-axis` del `flex-container`.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Alineaci√≥n en el eje secundario (`cross-axis`) cuando no hay m√∫ltiples l√≠neas de contenido
    Para alinear los elementos en el eje secundario cuando no existen m√∫ltiples l√≠neas de contenido, es decir, la propiedad "`flex-wrap`" tiene su valor por defecto: "`nowrap`" se utiliza la siguiente propiedad con los siguientes valores:

    - `align-items: strech;` </br>
    Es el valor por defecto. Estira a los `flex-items` que **no tengan declarada**  la dimensi√≥n correspondiente al `cross-axis` (eje secundario).

    - `align-items: flex-start` </br>
    Ubica a los `flex-items` al principio del `cross-axis` (eje secundario).

    - `align-items: flex-end` </br>
    Ubica a los flex-items al final del `cross-axis` (eje secundario).

    - `align-items: center` </br>
    Ubica a los `flex-items` en el centro del `cross-axis` (eje secundario).

    - `align-items: baseline;` </br>
    Ubica a los `flex-items` en la misma l√≠nea en la que se dibuja el texto.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Alineaci√≥n en el eje secundario (`cross-axis`) cuando hay m√∫ltiples l√≠neas de contenido
    Para alinear los elementos en el eje secundario cuando existen m√∫ltiples l√≠neas de contenido, es decir, la propiedad "`flex-wrap`" no tiene como valor a "`nowrap`" se utiliza la siguiente propiedad con los siguientes valores:

    - `align-content: strech;` </br>
    Es el valor por defecto. Estira los `flex-items` que **no tengan declarado** la dimensi√≥n correspondiente al `cross-axis` (eje secundario).

    - `align-content: flex-start;` </br>
    Ubica a los `flex-items` al principio del `cross-axis` (eje secundario), tratando a las `flex-lines` en conjunto.

    - `align-content: flex-end;` </br>
    Ubica a los `flex-items` al final del `cross-axis` (eje secundario), tratando a las `flex-lines` en conjunto.

    - `align-content: center;` </br>
    Ubica a los `flex-items` en el centro del `cross-axis` (eje secundario), tratando a las `flex-lines` en conjunto.

    - `align-content: space-between;` </br>
    Distribuye el espacio sobrante del `flex-container` alrededor del los `flex-items`. Exceptuando a los bordes, los cuales solo reciben espaciado interno.

    - `align-content: space-around;` </br>
    Distribuye el espaciado sobrante del `flex-container` alrededor de los `flex-items` equitativamente. Esto implica que los elementos que se encuentran a los bordes tengan un margen externo inferior a los que est√°n en el centro, dado que en Flexbox los m√°rgenes se suman.

    - `align-content: space-evenly;` </br>
    Distribuye el espaciado sobrante del `flex-container` alrededor de los `flex-items` equitativamente sin que ning√∫n elemento posea m√°s que otro.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

### Propiedades para los `flex-items` o elemento hijos directos del `flex-container`:

- #### Factor de encogimiento
    El concepto de Flexbox es crear layout a trav√©s de "cajas flexibles", se le dicen "flexibles" porque tienen la capacidad de encogerse o estirarse. Por defecto, de no caber todos los `flex-items` en una sola l√≠nea del `flex-container` estos se encoger√°n dado que tienen la siguiente propiedad declarada por defecto:

    ```css
    .flex-item
    {
        flex-shrink: 1;
    }
    ```
    Lo que indica que cada elemento tendr√° un factor de encogimiento igual a "1". Cabe destacar que esta propiedad recibe como valor n√∫meros enteros positivos. Funciona de la siguiente manera:

    Imaginemos que existe un `flex-container` de 800px de ancho. Dentro de √©l existen 10 `flex-items` de 100px de ancho cada uno.

    Haciendo el siguiente c√°lculo determinamos que los elementos no cabr√°n en el `flex-container`:

    * anchoFlexContainer = El `flex-container` mide 800px de ancho.
    * anchoFlexItems = 10 `flex-items` x 100px de ancho = 1000px.

    Entonces al estar activo el `flex-shrink` el navegador hace la siguiente operaci√≥n:

    * factorDeEncogimiento = anchoFlexItems - anchoFlexContainer
    * factorDeEncogimiento = 1000px - 800px
    * factorDeEncogimiento = 200px

    Esos 200px van a ser divididos en la  Œ£(sumatoria) del valor de `flex-shrink` en los elementos.

    Entonces como sabemos que existen 10 `flex-items` y cada uno tiene por defecto `flex-shrink: 1` seria:

    *  Œ£Flex-shrink = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
        >Cada "1" representa el valor de `flex-shrink` de cada `flex-items`.
    *  Œ£Flex-shrink = 10

    Teniendo todos los valores anteriores la redimensi√≥n de los elementos ser√° determinada por la siguiente f√≥rmula:

    * redimensi√≥n = factorDeEncogimiento / Œ£Flex-shrink

    * redimensi√≥n = 200px / 10

    * redimensi√≥n = 20px

    Ahora el valor de la redimensi√≥n se la va a **restar** a la dimensi√≥n correspondiente al eje principal, en este ejemplo el eje principal es horizontal por tanto se restar√° al `width`.

    * nuevoWidth = width - (flexShrinkDelElemento * redimensi√≥n)

    Como todos tiene el mismo `width` y el mismo `flex-shrink` entonces para cada uno ser√≠a:

    * nuevoWidth = 100px - (1 * 20px)
    * nuevoWidth = 80px

    Entonces todos los elementos se redimensionar√°n dado que no caben en el `flex-container`, pasando autom√°ticamente de 100px de ancho cada uno a tener 80px de ancho.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Factor de crecimiento
    Si bien el concepto de Flexbox es crear layout a trav√©s de "cajas flexibles" que por defecto se encogen de no haber espacio suficiente para los elementos, Flexbox tambi√©n permite que los `flex-items` **crezcan dependiendo del espacio sobrante**. Esto se hace con la siguiente propiedad:

    ```css
    .flex-item
    {
        flex-grow: 1;
    }
    ```

    Lo que indica que cada elemento `flex-items` tendr√° un factor de crecimiento igual a "1". Cabe recordar que esta propiedad a diferencia del `flex-shrink` no est√° activada por defecto. Esta propiedad recibe como valor n√∫meros enteros positivos y funciona de la siguiente manera:

    Imaginemos un `flex-container` de 800px de ancho. Dentro de √©l existen 10 `flex-items` de 50px de ancho.

    Comencemos obteniendo los datos de los elementos:

    * anchoFlexContainer = El `flex-container` mide 800px de ancho.
    * anchoFlexItems = 10 `flex-items` x 50px de ancho = 500px.

    Entonces al estar activo `flex-grow` el navegador hace la siguiente operaci√≥n:

    * espacioParaCrecer = anchoFlexContainer - anchoFlexItems
    * espacioParaCrecer = 800px - 500px
    * espacioParaCrecer = 300px

    Esos 300px van a ser divididos en la Œ£(sumatoria) del valor de `flex-grow` de cada `flex-items`.

    Entonces como sabemos que son 10 `flex-items` y cada uno de ellos tiene asignado un `flex-grow: 1` seria:

    *  Œ£Flex-grow = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
    >Cada "1" representa el valor de `flex-grow` de cada `flex-items`.
    *  Œ£Flex-grow = 10

    Con estos valores la redimensi√≥n ser√≠a:

    * redimensi√≥n = espacioParaCrecer / Œ£Flex-grow
    * redimensi√≥n = 300px / 10
    * redimensi√≥n = 30px

    Ahora el valor de redimensi√≥n se le **va a sumar** a la dimensi√≥n correspondiente al eje principal, en este ejemplo el eje principal es horizontal, por tanto se sumar√° al `width`:

    * nuevoWidth = width + (flexGrowDelElemento * redimensi√≥n)

    Como todos los `flex-items` tienen el mismo `flex-grow` y `width` entonces ser√≠a:

    * nuevoWidth = 50px + (1 * 30px)
    * nuevoWidth = 80px

    Entonces todos los elementos se redimensionar√°n pasando de tener 50px de ancho cada uno a tener 80px de ancho cada uno por tener factor de crecimiento.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Establecer la dimensi√≥n en el eje principal
    Existe una propiedad √∫nica de Flexbox que al entrar en conflictos bien sea con `width` o `height` siempre ganar√°. Esta propiedad es `flex-basis` la cual permite establecer una dimensi√≥n en el `main-axis` (eje principal).

    Por ejemplo si el `main-axis` es vertical (`flex-direction: column`) un `flex-basis: 30px;` determinar√° 30px de altura en el `flex-item` y aunque el height de dicho elemento estuviese declarado no lo tomar√≠a en cuenta.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Shorthand Flex
    Existe un shorthand que permite agrupar las propiedades anteriormente nombradas. Ex:

    ```css
    .flex-item
    {
        flex: [flex-grow] [flex-shrink] [flex-basis];
    }
    ```

    Algunos valores √∫tiles:

    * Crece o encoge el elemento dependiendo de la necesidad: `flex: auto;`

    * No permite crecer ni encoger al elemento: `flex: none;`

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>


- #### Alinear un `flex-item` en particular en el eje secundario (`cross-axis`)
    Permite alinear un elemento en particular en el eje secundario (`cross-axis`) usando la siguiente propiedad:

    ```css
    .flex-item:first-child
    {
        align-self: [valor];
    }
    ```

    Donde `[valor]` podr√≠a ser:

    * `flex-start`</br>
    Alinea al `flex-item` al principio del eje secundario o principio de la `flex-line` donde se encuentra.

    * `flex-end`</br>
    Alinea al `flex-item` al final del eje secundario o al final de la `flex-line` donde se encuentra.

    * `center`</br>
    Alinea al `flex-item` en el centro del eje secundario o en el centro de la `flex-line` donde se encuentra.

    * `baseline`</br>
    Alinea el `flex-item` teniendo en cuenta la l√≠nea de escritura del `flex-container` en el eje secundario o de la `flex-line` donde se encuentra.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Reescribir el orden en el que un elemento es dibujado por el navegador
    Se puede cambiar el orden en el que el navegador dibuja un elemento con Flexbox. Esto se hace con la siguiente propiedad:

    ```css
    .flex-item:first-child
    {
        order: 1;
    }
    ```

    Cabe destacar que todos los `flex-items` tienen por defecto "`order: 0`", entonces mientras m√°s lejos del 0 este, m√°s lejos lo dibujar√° el navegador y mientras cercano al 0 este o menor sea, el navegador lo dibujar√° m√°s al principio.

    >Nota: esta propiedad solo acepta n√∫meros enteros tanto positivos como negativos

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>


## Notas generales de los ejercicios de Flexbox
* Una etiqueta `<article>` puede tener dentro de s√≠ etiquetas como `<header>`, `<main>` y `<footer>`.

* Un `flex-item` puede ser a la vez un `flex-container`.

* Un Split Layout es un tipo de layout que consiste en ubicar el contenido a un lado y al otro lado una imagen o viceversa.

* El Split Layout puede generarse con la propiedad `order` de Flexbox o con los atributos de `row` y `row-reverse`.

* Una grilla o cuadricula con Flexbox se puede realizar pero t√©cnicamente no es mantenible al 100% autom√°ticamente. Es decir habr√≠a que recurrir a *hacks* para emular dicho aspecto. Ex:

    Si se quiere realizar una grilla de dos columnas con un espaciado entre columnas de 10px y un espaciado entre filas de 10px se debe:

    - El espaciado de columnas se har√≠a con `space-between`.
    - El espaciado de filas se har√≠a con `margin-bottom` aplicado a cada elemento que compone a la fila.
    - Las columnas se har√≠an con un `width: calc(50% - [espaciadoEntreColumnas])` y siempre deber√≠a de hacerse este c√°lculo por la determinada cantidad de columnas.

        Sin embargo hacer mantenible una grilla en la cual sus existan elementos que no tengan la misma cantidad de contenido o si le falta un elemento a la grilla har√° que se *desmaquete* haciendo muy dif√≠cil de mantener.

    - Si un `flex-item` contiene activa la propiedad `float` esta no surtir√° efecto puesto que prevalecer√° Flexbox.

    - Por defecto Flexbox tratar√° en lo posible de igual la altura de los elementos que est√°n en un `flex-container` a la altura del hijo m√°s alto. Esto es posible por su valor por defecto "`strech`" bien sea en su propiedad `align-items` o `align-content`.
        >Esto sucede si no se ha declarado previamente la altura de los elementos.


<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

## ¬øQu√© es CSS Grid Layout?
Es un nuevo m√≥dulo de CSS que permite construir layouts con una alineaci√≥n en dos ejes mediante filas y columnas.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

## Terminolog√≠a de CSS Grid Layout

1. `grid-container`: Es el contenedor que recibe la propiedad de `display: grid;`.

2. `grid-items`: Son los hijos directos del `grid-container`.

3. `grid-lines`: Son las l√≠neas horizontales y verticales que conforman las filas y columnas del Grid. Permite ordenar los elementos con una gran libertad sin importar el flujo en el que est√°n en el HTML. OJO: No son las filas o columnas, son las **L√çNEAS** que las construye.

4. `grid-tracks`: Son espacios del Grid que est√°n limitados por dos `grid-lines` consecutiva, es decir, son aquellos espacios generados por las filas o columnas. Un `grid-track` podr√≠a ser una columna completa o una fila completa.

5. `grid-area`: Es cualquier rect√°ngulo que est√° limitado por `grid-lines`.

6. `grid-cells`: Es el espacio resultante encontrado en las intersecciones de las filas y columnas.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

## Propiedades de CSS Grid Layout
### Para el `grid-container` (elemento padre):

- #### Activar CSS Grid Layout
    Se puede activar CSS Grid Layout con la siguiente propiedad:

    ```css
    .grid-container
    {
        display: grid;
    }
    ```

    El comportamiento por defecto de este nuevo modelo de layout puede verse afecto por la existencia de la grilla, es decir, que ya se hayan declarado las filas y columnas o por la existencia de `grid-lines`.

    Si el `grid-container` no posee `grid-items` no se ver√° ning√∫n efecto aplicado al `grid-container`, sin embargo si posee `grid-items` CSS Grid Layout crear√° una fila por cada `grid-items` para ubicarlos.

    Si el `grid-container` posee una grilla declarada (ya se declararon las filas y columnas) CSS Grid Layout colocar√° los elementos en cada `grid-cells` existente partiendo de izquierda a derecha y de arriba a abajo.

    >Nota: Al no haber declarado las filas y columnas de la grilla los elementos se posicionar√°n uno en cada fila diferente autom√°ticamente porque se crea un "Grid Impl√≠cito" y como la propiedad que controla la direcci√≥n del contenido que se encuentra en el Grid Impl√≠cito (`grid-auto-flow`) est√° con su valor por defecto de "`row`", es decir, "fila".

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Controlar el flujo de los elementos en el Grid Impl√≠cito
    Por defecto al aplicar CSS Grid Layout pero sin declarar las filas y columnas pertenecientes al mismo, CSS Grid Layout lo que har√° es crear una fila para posicionar cada `grid-items` adyacente en √©l. Esto ocurre por la siguiente propiedad:

    ```css
    .grid-container
    {
        grid-auto-flow: [valor];
    }
    ```

    Donde `[valor]` podr√≠a ser:

    * `row`</br>
    Es el valor por defecto. Coloca los elementos sobrantes o que no caben en una nueva fila en el Grid Impl√≠cito. Esto lo hace por cada `grid-items` que no quepa en el Grid Expl√≠cito.

    * `column`</br>
    Coloca a los elementos sobrantes o que est√°n en el Grid Impl√≠cito en una columna diferente. Esto lo hace por cada `grid-items` que no quepa en el Grid Expl√≠cito.

    * `dense`</br>
    Al aplicar solo el valor de "`row`" o "`column`" y debido a su acci√≥n puede que se creen "huecos" en el Grid. Esto podr√≠a solucionarse usando en conjunto el valor de "`dense`", el cual intenta llenar los "huecos" resultantes con el pr√≥ximo elemento m√°s cercano que pueda caber en dicho "hueco" o espacio sobrante.

        CSS Grid Layout coloca los elementos por defecto en filas con direcci√≥n de izquierda a derecha y de arriba a abajo. O si est√° configurada en columnas de arriba a abajo y de izquierda a derecha.
    
        Sin embargo cuando se crean "huecos" bien sea por el posicionamiento de un elemento el navegador lo que intenta es buscar un espacio donde quepa dicho elemento y lo hace buscando en el sentido antes dicho y una vez encontrado posiciona al elemento y despu√©s continua posicionando a los dem√°s elementos y dejando (posiblemente) un "hueco" producto de la redimensi√≥n del elemento el cual puede llenarse alterando el orden con el valor de  "`dense`" independientemente de si el `grid-auto-flow` est√° en `column` o `row`.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Declarar filas en CSS Grid Layout
    Para declarar filas en CSS Grid Layout se usa la siguiente propiedad:

    * `grid-template-rows: [valor];`</br>
    En donde `[valor]` podr√≠a ser cualquier unidad de medida (`px`, `em`, `vh`, etc). Adem√°s de que por cada valor que se le agregue se crear√° autom√°ticamente una fila. Por ejemplo si queremos dos filas: una de 100px y otra del 20% la declaraci√≥n ser√≠a:

        ```css
        .grid-container
        {
            grid-template-rows: 100px 20%;
        }
        ```

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Declarar columnas en CSS Grid Layout
    Para declarar columnas en CSS Grid Layout se usa la siguiente propiedad:

    * `grid-template-columns: [valor];`</br>
    En donde `[valor]` podr√≠a ser cualquier unidad de medida (`px`, `em`, `vh`, etc). Adem√°s de que por cada valor que se le agregue se crear√° autom√°ticamente una columna. Por ejemplo si se quieren tres columnas: una de 100px, otra de 50% y una √∫ltima de 2em, ser√≠a:

        ```css
        .grid-container
        {
            grid-template-columns: 100px 50% 2em;
        }
        ```

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Declararle nombre a las filas o columnas
    Es posible darle nombre a las l√≠neas al momento de declarar los `grid-tracks` bien sean columnas o filas. Lo √∫nico que hay que tener en cuenta es que siempre habr√° una l√≠nea sin dimensiones, es decir, el total de l√≠neas ser√≠a: l√≠neasDeclaradas + N, donde "N" representa la √∫ltima l√≠nea (el final) que no tienen dimensiones.

    La estructura de la declaraci√≥n seria:

        [nombreDeLinea] [dimensi√≥n]


    ```css
    .grid-container
    {
        grid-template-columns: [start] 1fr
                               [middle] 1fr
                               [end];
    }
    ```

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Nueva unidad de medida de CSS Grid Layout
    CSS Grid Layout introduce una nueva unidad de medida la cual es la "fracci√≥n" (`fr`) la cual trabaja parecido al factor de crecimiento/encogimiento de Flexbox. Es decir, el espacio sobrante se divide entre la sumatoria de fracciones y luego dicho resultado es multiplicado por el valor en fracciones de cada fila o columna. Ex:

    ```css
    .grid-container
    {
        grid-template-columns: 1fr 1fr;
    }
    ```

    En dicho ejemplo existen dos columnas de `1fr` cada una. Entonces la sumatoria ser√≠a: 1fr + 1fr = 2fr. El espacio sobrante (que al no tener ninguna dimensi√≥n fija declarada ser√≠a del 100%) se dividir√≠a entre la sumatoria de la siguiente forma: 100% / 2fr = 50%. Entonces cada fracci√≥n tendr√≠a una dimensi√≥n del 50%.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Funci√≥n `repeat()` de CSS Grid Layout
    Por la forma repetitiva en la que se declaran las filas y columnas en CSS Grid Layout existe la funci√≥n "`repeat()`" siendo exclusiva de CSS Grid Layout, la cual permite repetir un valor "n" cantidad de veces. Se usa de la siguiente manera:

    ```css
    repeat([n], [valor]);
    ```

    Donde `[n]` representa la cantidad de veces que se repetir√° el `[valor]` y `[valor]` a su vez representa el valor deseado a repetirse.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Funci√≥n `minmax()` de CSS Grid Layout
    Existe una nueva funci√≥n de CSS Grid Layout que se utiliza para establecer dimensiones, esta funci√≥n es `minmax()` la cual trabaja as√≠:

    ```css
    .grid-container
    {
        grid-template-columns: minmax([min], [max]);
    }
    ```

    Donde `[min]` ser√° el valor m√≠nimo que tendr√° dicha dimensi√≥n. Y `[max]` corresponde al valor m√°ximo que puede alcanzar dicha dimensi√≥n.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Espaciado en el Grid
    Es posible definir el espaciado entre filas y columnas a trav√©s del uso de las siguientes propiedades:

    * `column-gap: [valor];`</br>
    Es la propiedad que permite declarar el espaciado correspondiente a las columnas.

    * `row-gap: [valor];`</br>
    Es la propiedad que permite declarar el espaciado correspondiente a las filas.

    * `gap: [valor];`</br>
    Es un shorthand que permite a trav√©s de dos valores diferentes o (el mismo para ambos) dar espaciados tanto a filas y columnas.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Alineaci√≥n de los `grid-items`
    CSS Grid Layout permite alinear sus `grid-items` con respecto a las `grid-cells` donde se encuentra. Esto se hace a trav√©s de las siguientes propiedades:

    * `justify-items: [valor];`</br>
    Permite alinear los `grid-items` con respecto a la anchura (horizontalmente) de la `grid-cell` donde se encuentra.

    * `align-items: [valor];`</br>
    Permite alinear los `grid-items` como respecto a la altura (verticalmente) de la `grid-cell` donde se encuentra.

    Ambas propiedades reciben como `[valor]` los siguientes:

    * `strech`</br>
    Es el valor por defecto. Estira al `grid-items` hasta cubrir por completo la `grid-cells` bien sea vertical u horizontalmente.

    * `start`</br>
    Permite colocar al `grid-item` al principio (del eje en el que se usa) de la `grid-cell` y hace que el elemento se redimensione dependiendo de su contenido. Es decir, solo ocupar√° el espacio que necesita en la `grid-cells`.

    * `end`</br>
    Permite colocar al `grid-item` al final (del eje en el que se usa) de la `grid-cell` y hace que el elemento se redimensione dependiendo de su contenido. Es decir, solo ocupar√° el espacio que necesite en la `grid-cell`.

    * `center`</br>
    Permite colocar al `grid-item` en el centro (del eje en el que se usa) de la `grid-cell` y hace que el elemento se redimensione dependiendo de su contenido. Es decir, solo ocupar√° el espacio que necesite en la `grid-cell`.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Alineaci√≥n del Grid dentro del `grid-container` en CSS Grid Layout
    CSS Grid Layout permite alinear el Grid que contiene el `grid-container` siempre y cuando el Grid resultante **no ocupe el 100%** del tama√±o (alto y ancho del `grid-container`) es decir, se necesita de espacio sobrante dentro del `grid-container`. Se hace de la siguiente manera:

    * `justify-content: [valor];`</br>
    Permite alinear las filas del Grid con respecto al `grid-container`. Es la alineaci√≥n horizontal.

    * `align-content: [valor];`</br>
    Permite alinear las columnas del Grid con respecto al `grid-container`. Es la alineaci√≥n vertical.

    Ambas propiedades reciben como `[valor]` los siguientes:

    * `strech`</br>
    Es la propiedad por defecto. Estira la grilla hasta cubrir por completo la dimensi√≥n asignada.

    * `start` </br>
    Permite colocar al Grid al principio del `grid-container` seg√∫n el eje que corresponda.

    * `end`</br>
    Permite colocar al Grid al final del `grid-container` seg√∫n el eje que corresponda.

    * `center`</br>
    Permite colocar al Grid en el centro del `grid-container` seg√∫n el eje que corresponda.

    * `space-around`</br>
    Le otorga al Grid un espaciado alrededor del `grid-container` seg√∫n el eje que corresponda.

    * `space-between`</br>
    Le otorga al Grid un espaciado a los `grid-tracks` internos (no a los ubicados en los bordes) seg√∫n el eje que corresponda.

    * `space-evenly`</br>
    Le otorga al Grid un espaciado a los `grid-tracks` de forma homog√©nea. Es decir, tanto a los ubicados en los bordes como los internos tendr√°n la misma separaci√≥n. Esto sucede teniendo en cuenta el eje donde corresponda.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>


### Propiedades de los `grid-items` (hijos directos del `grid-container`):

- #### Posicionar un `grid-items` horizontalmente seg√∫n las `grid-lines` de las filas
    Es posible posicionar un elemento seg√∫n las `grid-lines` resultantes de las filas que se crean debido al Grid Expl√≠cito. Esto se hace con la siguiente propiedad:

    ```css
    .grid-items:first-child
    {
        grid-row-start: [row-start];
        grid-row-end: [row-end];
    }
    ```

    En donde `[row-start]` representa al n√∫mero de l√≠nea en la que va a iniciar y `[row-end]` representa al n√∫mero de l√≠nea en la que va a terminar.

    Sin embargo se puede usar la palabra reservada "`span`" para indicar cuantos `grid-tracks` se quiere que ocupe en lugar de estar contando las l√≠neas.

    Tambi√©n se puede especificarse a trav√©s del siguiente shorthand:

    ```css
    .grid-items:first-child
    {
        grid-row: [row-start] / [row-end];
    }
    ```

    >Nota: Si se omiten los finales de `grid-row` y `grid-column`, pero si se declara el inicio, es decir, el `row-start` y el `column-start`, el `grid-item` que se est√© manipulando empezar√° en el punto que se le indic√≥ pero terminar√° ocupando solo una celda. Es decir, terminar√° en la pr√≥xima `grid-line` m√°s cercana.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Posicionar un `grid-item` verticalmente seg√∫n las `grid-lines` de las columnas
    Es posible posicionar un elemento seg√∫n las `grid-lines` resultantes de las columnas que se crean debido al Grid declarado. Esto se hace con las siguientes propiedades:

    ```css
    .grid-items:first-child
    {
        grid-column-start: [column-start];
        grid-column-end: [column-end];
    }
    ```

    En donde `[column-start]` representa el n√∫mero de l√≠nea en la que va a iniciar y `[column-end]` respresenta el n√∫mero de l√≠nea en la que va a terminar.

    Sin embargo se puede usar la palabra reservada "`span`" para indicar cuantos `grid-tracks` se quiere que ocupe en lugar de estar contando las l√≠neas.

    Tambi√©n se puede especificarse a trav√©s del siguiente shorthand:

    ```css
    .grid-items:first-child
    {
        grid-column: [column-start] / [column-end];
    }
    ```

    >Nota: Si se omiten los finales de `grid-row` y `grid-column`, pero si se declara el inicio, es decir, el `row-start` y el `column-start`, el `grid-item` que se est√© manipulando empezar√° en el punto que se le indic√≥ pero terminar√° ocupando solo una celda. Es decir, terminar√° en la pr√≥xima `grid-line` m√°s cercana.

- #### Shorthand para posicionar `grid-items` horizontal y verticalmente seg√∫n las `grid-lines`
    Se usa la siguiente propiedad:

    ```css
    .grid-items:first-child
    {
        grid-area: [row-start] / [column-start] / [row-end] / [column-end];
    }
    ```

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Alinear un `grid-items` en particular
    A trav√©s de CSS Grid Layout se puede alinear un `grid-item` en particular seg√∫n el espacio que tenga en su `grid-cells`. Se hace de la siguiente manera:

    * Alineaci√≥n horizontal</br>
    Se usa la siguiente propiedad:
        ```css
        .grid-items:first-child
        {
            justify-self: [valor];
        }
        ```

    * Alineaci√≥n Vertical</br>
    Se usa la siguiente propiedad:
        ```css
        .grid-items:first-child
        {
            align-self: [valor];
        }
        ```

    Ambas propiedades pueden recibir alguno de las siguientes opciones como `[valor]`:

    * `strech`</br>
    Es el valor por defecto. Estira al elemento a todo lo que da en el eje de la `grid-cells` donde se ubica.

    * `center`</br>
    Posiciona al `grid-items` al centro del eje de la `grid-cells` donde se ubica, ocupando solo el espacio requerido por su contenido.

    * `start`</br>
    Posiciona al `grid-items` al principio del eje de la `grid-cell` donde se ubica ocupando solo el espacio requerido por su contenido.

    * `end`</br>
    Posiciona al `grid-items` al final del eje de la `grid-cells` donde se ubica ocupando solo el espacio requerido por su contenido.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

- #### Posicionar elementos con nombres de √°reas
    Si se quisiera realizar el siguiente layout d√°ndole nombre a los elementos se har√≠a de la siguiente manera:

    Realizar el siguiente layout el cual contiene 3 filas y 3 columnas.


        |---------------------|
        |        Header       |
        |---------------------|
        | Side |  Contenido   |
        |---------------------|
        |       Footer        |
        |---------------------|

    #### Parte A: Establecer el Grid
    Primero se definir√≠a el Grid container con la dimensiones de las filas y columnas que necesitar√≠a el layout. Ex:

    ```css
    .grid-container
    {
        /* con su altura necesaria */
        min-height: 100vh;

        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);
    }
    ```

    #### Parte B: Declarar la disposici√≥n de las √°reas
    Tal como si se estuviera estableciendo el layout a trav√©s de palabras se har√≠a con la siguiente propiedad dentro del `grid-container`:

    ```css
    .grid-container
    {
        /* Previamente*/
        min-height: 100vh;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: repeat(3, 1fr);

        grid-areas: "header header header"
                    "sidebar main main"
                    "footer footer footer";
    }
    ```

    Donde como puede observarse se declaran nombres arbitrarios a las √°reas las cuales representar√°n la posici√≥n dentro del layout, y como puede observarse se pueden repetir tantas veces como columnas o filas deba abarcar.

    #### Parte C: Asignar las √°reas a los elementos
    Previamente escrito el HTML con los elementos que conformar√°n el layout se procede a asignarle las √°reas con la siguiente propiedad:

    ```css
    header.grid-item{ grid-area: header; }

    aside.grid-item{ grid-area: sidebar; }

    main.grid-item{ grid-area: main; }

    footer.grid-item{ grid-area: footer; }
    ```

    **Nota**: Las √°reas declaradas podr√≠an abarcar (repetirse en su declaraci√≥n) tanto a filas como columnas. La √∫nica limitante es que las √°reas solo pueden ser rectangulares por ejemplo:

    ```css
    .grid-container
    {
    grid-areas: "sidebar header header"
                "sidebar main main"
                "sidebar footer footer";
    }
    ```

    Es importante recalcar que cuando se declaran `grid-areas` se crean l√≠neas relacionadas a los `grid-tracks` resultantes  autom√°ticamente con el mismo nombre de las √°reas. Es decir, cada vez que se crea un √°rea se crean l√≠neas alrededor de dicho tracks cuyos nombres son `[nombreDe√Årea]-start` y `[nombreDe√Årea]-end`, en otras palabras las l√≠neas tienen nombres impl√≠citos relativos a las √°reas.

    Entonces teniendo en consideraci√≥n esto, la siguiente declaraci√≥n podr√° ser v√°lida:

    ```css
    aside.grid-item
    {
        grid-column: sidebar-start / sidebar-end;
        grid-row: sidebar-start / sidebar-end;
    }
    ```
    >Aunque a simple vista no se diferencia cuales son las horizontales de las verticales, es en la propiedad que se diferencia dado que llevan el mismo nombre por la forma en la que se declaran en el `grid-area`.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

## Notas generales de los ejercicios de CSS Grid Layout

* Cuando en la f√≥rmula de un `nth-child()` se coloca la "`n`" negativa seguida de una suma a un n√∫mero se est√° haciendo referencia a los primeros X elementos. Ex:

    ```css
    .grid-items:nth-child(-n+8)
    {
        /* Estilos */
    }
    ```

    En esta regla se est√° refiriendo a los primeros 8 elementos.

* Al usar `display: grid;` se puede usar en los `grid-items` la propiedad `order` y `z-index` si necesidad de posicionar los elementos o aplicar Flexbox respectivamente.

* Cuando un `grid-item` se sale del Grid Expl√≠cito, es decir, del que hemos declarado bien sea con √°reas o filas y columnas, el navegador crea un Grid Impl√≠cito con dimensiones en "`auto`" para filas y columnas.

    Esto quiere decir, que si un elemento se va a desbordar (o salirse del Grid Expl√≠cito) por una declaraci√≥n err√≥nea en las columnas el navegador crear√° m√°s columnas con el ancho en "`auto`".

    Sin embargo si esto sucede en las filas al estar la dimensi√≥n en "`auto`" la misma ser√° de 0 (cero) dado que por defecto se ajustan al contenido, hasta llegar a la fila o `grid-line` necesitada para ubicar al elemento.

    Para controlar esto, es decir, el Grid Impl√≠cito se usan las siguientes propiedades dependiendo del caso:

    ```css
    grid-auto-row: [valor];
    grid-auto-column: [valor];
    ```

    Los cuales sirven para indicar el tama√±o que tendr√° las filas o columnas que se podr√≠an generar por un desbordamiento, es decir, para controlar el tama√±o del Grid Impl√≠cito.

* Para hacer *Cross Browser* se hace usando la condicional de CSS:

    ```css
    @supports (condicional)
    {
        /* estilos */
    }
    ```

    La cual funciona de la siguiente manera: En la condici√≥n se coloca la propiedad que se espera que sea soportada y en el contenido de query los estilos correspondientes si se soporta dicha propiedad. Ex:

    ```css
    /*Si se soporta GRID*/
    @support (grid-template-areas: "sidebar")
    {
        /* estilos */
    }
    ```

    >Nota: La condici√≥n debe incluir la [propiedad] y el [valor] sin importar que este sea falso o de prueba.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

## Arquitectura CSS
La arquitectura seg√∫n Wikipedia es la: "T√©cnica y estilo con los que se dise√±a, proyecta y construye un edificio o monumento".

Aplicando el concepto a CSS ser√≠a:
T√©cnicas que nos ayudan a organizar y mantener nuestro c√≥digo CSS de manera √≥ptima y saludable abstray√©ndolo y dividi√©ndolo en m√≥dulos y/o componentes que permitir√°n su reutilizaci√≥n y escalabilidad de manera estructurada y ordenada.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

## ¬øQu√© son los componentes?
Se puede decir que un componente es aquel que cumple con las siguientes caracter√≠sticas:

- Un fragmento de la interfaz que cumple una √∫nica funci√≥n.
- Son independientes, tanto de su contexto como del resto de componentes.
- Son reutilizables.
- Son auto contenidos, es decir, no filtran estilos a los otros componentes.

La primera persona que propuso el enfoque de componentes fue "Nicole Sullivan" en una charla en la cual dec√≠a que estos componentes eran:

<blockquote>
    <cite>It's a repeating visual pattern, that can be abstracted into a independent snippet of HTML, CSS and possibly JavaScript</cite>
</blockquote>

Un ejemplo de un componente podr√≠a ser un plugin de Wordpress o de JQuery.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

## Patrones de dise√±o
Los patrones de dise√±o son la base de la b√∫squeda de soluciones a problemas comunes en el desarrollo de software y otros √°mbitos referentes al dise√±o de interacci√≥n o interfaces.

Un patr√≥n resulta ser una soluci√≥n a un problema. Para que una soluci√≥n sea considerada un patr√≥n debe:

- Comprobar su efectividad resolviendo problemas similares.
- Ser reutilizables lo que significa que es aplicable a diferentes problemas en distintas circunstancias.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

### ¬øPor qu√© usar patrones en CSS?
Debemos usar patrones de dise√±o en CSS dado que:

- Construimos sistemas no p√°ginas.
- Necesidad de modularidad.
- Mejora el flujo de trabajo.
- Ya han sido probados y validados.
- Si se trabaja en equipos mantienen el orden.
- Promueve la filosof√≠a *DRY* (Don't Repeat Yourself).


<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

## Gu√≠as de estilos
Las gu√≠as de estilos son convenciones humanas que se siguen al escribir c√≥digo. Esto se hace con la finalidad de que si est√°n trabajando m√°s de un desarrollador el c√≥digo luzca como si lo fuera hecho una sola persona, manteniendo as√≠ un c√≥digo m√°s legible y f√°cil de mantener. Entre algunas de las gu√≠as de estilos m√°s famosas est√°n:

- Airbnb / Sass Styleguide
- Idiomatic CSS
- CSS Guideline
- Code Guide
- Primer de GitHub

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

## Tipos de Arquitecturas
Cuando se comienza con CSS se suele pensar que basta con saber las propiedades y sus posibles valores, pero r√°pidamente este enfoque cambia a medida que el proyecto crece y surge la necesidad de cambios o de integrar m√°s desarrolladores al proyecto.

Es ah√≠ cuando surgen la necesidad de aplicar arquitecturas de CSS para mantener el CSS lo m√°s sano y legible posible sin importar que tan antiguo sea o cuantas personas est√©n involucradas.

Cabe destacar que estas arquitecturas son "convenciones humanas", es decir, no se marcara como error alguna parte del c√≥digo si no se siguen correctamente o si se les modifica alguna parte de la misma.

Entre las arquitecturas m√°s usadas est√°n:

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

### SMACSS: Scalable and Modular Architecture for CSS
Es la traducci√≥n de "Arquitectura Modular y Escalable para CSS", la cual permite realizar proyectos con CSS dividiendo el c√≥digo en categor√≠as, las cuales son:

1. Base</br>
Son los estilos base que se le aplican a los elementos usando un selector de etiqueta o descendiente haciendo uso de los `nth-child()` o cualquier pseudoclase. B√°sicamente es donde se ubican los reset o estilos base. Ex:

    ```css
    body{ /*Estilos base*/ }

    a{ /*Estilos base*/ }

    a:hover{ /*Estilos base*/ }
    ```

2. Layout </br>
Son los estilos que definen la organizaci√≥n de los bloques grandes en la maquetaci√≥n de la p√°gina. Por ejemplo: la anchura del header, del aside o del footer.

    Seg√∫n SMACSS existen dos tipos de componente: los mayores (que son los que corresponden a esta categor√≠a), los cuales son los espacios donde estar√°n los "menores" que son los componentes que est√°n ubicados dentro, por ejemplo:

    Un componente mayor (de layout) ser√≠a un `#header` y un componente menor (m√≥dulo) ser√≠a el `.nav`

    En SMACSS se puede usar ID para nombrar a los componentes de layout. Ex:

    ```css
    #header,
    #article,
    #footer
    {
        width: 960px;
        margin: auto;
    }

    #article
    {
        border: solid #ccc;
        border-width: 1px 0 0;
    }
    ```

    Puede darse el caso que se necesite repetir un estilo de layout a otro componente y por estar con `#ID` no se pueda realizar. Por eso **se recomienda** usar clases con el prefijo "l-" para saber que corresponde a estilos de la categor√≠a layouts y permita su reutilizaci√≥n. Ex:

    ```css
    .l-flipped #article
    {
        /*Estilos*/
    }

    .l-flipped #sidebar
    {
        /*Estilos*/
    }
    ```

3. Module</br>
Los M√≥dulos o componentes son aquellos que viven dentro de los componentes de layout. Por ejemplo un men√∫ de navegaci√≥n, un carrousel, un widget, etc. Cuando se declaran m√≥dulos se evita el uso de `#ID`. Ex:

    ```css
    .module > h2
    {
        /*Estilos*/
    }
    ```

4. State</br>
Son reglas que hacen referencia al estado, las cuales se aplican cuando un elemento cambia con (posiblemente) JavaScript o por la intervenci√≥n del usuario.

    Son reglas que sobrescriben alg√∫n estilo. Por ejemplo un acorde√≥n se le aplica el estado "activo" cuando se despliega:

    ```html
    <div id="header" class="is-collapsed">
        <form>
            <div class="msg is-error">
                There is an error!
            </div>
            <label for="searchbox" class="is-hidden">
                Search
            </label>
            <input type="search" id="searchbox" />
        </form>
    </div>
    ```

    Generalmente estas reglas llevan el prefijo "is-" como se ve en el ejemplo anterior: "is-hidden", "is-active", "is-collapsed", etc.

5. Theme </br>
Corresponde a las reglas de tema englobando colores, im√°genes y tipograf√≠as. Son los estilos que le dan el *Look and Feel* al sitio.

>Nota general: Para SMACSS **es recomienda** utilizar un preprocesador para dividir el c√≥digo en archivos separados seg√∫n la categor√≠a y que el preprocesador al compilarlos los una en un solo archivo al final.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

### OOCSS: Object-Oriented CSS
Es la traducci√≥n de "CSS orientado a objetos" Permite realizar proyectos con CSS teniendo en cuenta dos principios fundamentales:

1. Separar la estructura (HTML) de la presentaci√≥n (CSS)</br>
Para aplicar la regla de separar la estructura del dise√±o en OOCSS se debe diferenciar las propiedades que modifican la estructura de las propiedades que modifican el dise√±o. Para ello se crean diferentes estilos sin mezclar propiedades de estos dos grupos.

    Por ejemplo las propiedades: `padding` o `margin` son propiedades que modifican la estructura o maquetaci√≥n. Mientras que `color` o `border` son propiedades que modifican la visualizaci√≥n pero no la maquetaci√≥n.

    Estos son dos ejemplos de estilos que mezclan propiedades de estructura como de dise√±o:

    ```css
    .block-red
    {
        width: 200px;
        height: 50px;
        padding: 10px;
        border: 1px solid #000;
        background: linear-gradient(#ccc, #f00);
    }

    .block-blue
    {
        width: 200px;
        height: 50px;
        padding: 10px;
        border: 1px solid #000;
        background: linear-gradient(#ccc, #00f);
    }
    ```

    En los estilos anteriores teniendo en cuenta el principio anterior, podemos detectar que:

    - La estructura no est√° separada del dise√±o.
    - Existen propiedades de estructura que se repiten en ambas clases.
    - Las propiedades de estilos no son reutilizables en otros elementos.

    Aplicando la primera regla de OOCSS los estilos quedan de la siguiente forma:

    ```css
    .block
    {
        width: 200px;
        height: 50px;
        padding: 10px;
    }
    .red
    {
        border: 1px solid #000;
        background: linear-gradient(#ccc, #f00);
    }
    .blue
    {
        border: 1px solid #000;
        background: linear-gradient(#ccc, #00f);
    }
    ```

2. Separar el contenido de sus contenedores </br>
Esta regla trata de evitar que los estilos dependan del contenedor en el que est√°n; dada la estructura del HTML ya que esto hace que el estilo aplicado al contenido no sea reutilizable.

    Estos son dos ejemplos de estilos en lo que el contenido y el contenedor tienen una dependencia:

    ```css
    header h1
    {
        font-family: "Roboto", Helvetica, sans-serif;
        font-size: 2em;
        color: #f44;
    }

    footer h1
    {
        font-family: "Roboto", Helvetica, sans-serif;
        font-size: 1.5em;
        opacity: 0.5;
        filter: opacity(0.5);
        color: #f44;
    }
    ```

    Aplicando OOCSS para separar el contenido del contenedor los estilos se transformar√°n en los siguientes:

    ```css
    h1
    {
        font-family: "Roboto", Helvetica, sans-serif;
        color: #f44;
    }

    h1,
    .h1-size
    {
        font-size: 2em;
    }

    h2,
    .h2-size
    {
        font-size: 1.8em;
    }

    h3,
    .h3-size
    {
        font-size: 1.5em;
    }

    .muted
    {
        opacity: 0.5;
        filter: opacity(0.5);
    }
    ```

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

### ITCSS: Inverted Triangle Architecture for CSS
Es la traducci√≥n de "Arquitectura de Triangulo Invertido para CSS". Permite realizar proyectos con CSS dividiendo el c√≥digo en capas, adem√°s de permitir su uso en conjunto con otras metodolog√≠as.

ITCSS en palabras de su creador; Harry Roberts es:

* Es una sana y escalable forma de manejar la arquitectura.
* No es una librer√≠a, es una forma de pensar.
* Es un meta-framework, es decir, un framework para framework.
* Es incre√≠blemente simple.

ITCSS propone categorizar el CSS para que el c√≥digo CSS quede lo m√°s ordenado posible y acabar as√≠ con las <span style="text-decoration:underline;">guerras de especificidad</span>, de forma de que a medida que avance el c√≥digo se vaya de lo gen√©rico a lo espec√≠fico como puede evidenciarse en la siguiente gr√°fica:

<div align="center">
    <img src="img/itcss.png" alt="Gr√°fico de especificidad de ITCSS" width="400px" />
    <small><p>Gr√°fico de especificidad de ITCSS.</p></small>
</div>

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

#### Capas de ITCSS

Como puede observarse en la imagen, ITCSS consta de varias "capas" las cuales son:

1. Settings </br>
Si se trabaja con un preprocesador es en esta capa donde ir√°n las variables, configuraciones generales, etc. Ex:

    ```scss
    //SASS

    $color-ui: #BADA55;
    $spacing-unit: 10px;
    ```

2. Tools </br>
Si se est√° trabajando con un preprocesador; es en esta capa donde ir√°n los mixin, las funciones, helpers, etc. Ex:

    ```scss
    //SASS

    @mixin font-brand()
    {
        font-family: "UI Font", sans-serif;
        font-weight: 400;
    }
    ```

3. Generic </br>
Es reci√©n en esta capa donde se escribe CSS que puede apreciarse en una gr√°fica de especificidad. En esta capa se ubican los estilos gen√©ricos o de etiquetas como podr√≠a ser un reset, un normalize o el `box-sizing`. Etc:

    ```css
    *
    {
        box-sizing: border-box;
    }
    ```

4. Base </br>
Son estilos aplicados a etiquetas HTML sin uso de clase o ID's. Ex:

    ```css
    ul
    {
        list-style: square outside;
    }
    ```

5. Objects </br>
Son elementos que pueden ser reutilizados en el proyecto o los que no se le aplican <span style="text-decoration:underline;">estilos cosm√©ticos</span>, es decir, como OOCSS; es la estructura separada de la presentaci√≥n. Deben de usar clases y los nombres de las clases han de ser agn√≥sticos. Ex:

    ```scss
    //SASS

    .ui-list
    {
        margin: 0;
        padding: 0;
        list-style: none;
    }

    .ui-list__item
    {
        padding: $spacing-unit;
    }
    ```

6. Components </br>
Son pedazos de UI dise√±ados. Son como los m√≥dulos de SMACSS o la segunda regla de OOCSS. Se siguen usando clases pero con nombres m√°s espec√≠ficos. Ex:

    ```scss
    // SASS

    .product-list
    {
        @include font-brand()
        border-top: 1px solid $color-ui;
    }

    .product-list__item
    {
        border-bottom: 1px solid $color-ui;
    }
    ```

7. Trumps </br>
Son utilidades muy espec√≠ficas como los helpers o c√≥digo que sobrescribe estilos (modificadores), afectando a una pieza del DOM a la vez. A veces se suele usar el `!important`. Ex:

    ```css
    .one-half
    {
        width: 50% !important;
    }
    ```

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

#### Escalar la arquitectura ITCSS
ITCSS es sumamente flexible con su forma de trabajo tal que:

- Se pueden a√±adir o remover capas cuando se necesiten.
- Si no se usa un preprocesador se puede quitar la capa de Settings y Tools.
- Si no se usa OOCSS se puede remover la capa de Objects.
- Si se necesita una capa de Theme se puede incorporar sin ning√∫n problema solo hay que tener en cuenta que su ubicaci√≥n ser√≠a antes de la capa de Trumps.

Siempre se debe recordar que para a√±adir capas:

- Se deben a√±adir en el lugar correcto.
- La especificidad y la explicidad de los selectores determinar√° la ubicaci√≥n.
- Se debe hacer honor a la gr√°fica de especificidad, es decir, siempre la tendencia debe ser ascendente sin reca√≠das.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

### Atomic Design
Es una arquitectura que hace referencia a la qu√≠mica, en la cual los elementos que intervienen en la metodolog√≠a "evolucionan" pasando de:

- √Åtomos a mol√©culas.
- Mol√©culas a organismos.
- Organismos a templates.
- Templates a p√°ginas.

<div align="center">
    <img src="img/atomic-desing.png" alt="Elementos del Atomic Design" width="400px" />
    <small><p>Elementos del Atomic Design.</p></small>
</div>

#### √Åtomos
Al igual que la qu√≠mica es la parte m√°s peque√±a e indivisible de un elemento. En el contexto de CSS se estar√≠a hablando por ejemplo de un label, un input, o un bot√≥n, etc.

<div align="center">
    <img src="img/atomo.png" alt="√Åtomos" width="400px" />
    <small><p>√Åtomos.</p></small>
</div>


#### Mol√©culas
Son un conjunto de √°tomos que mezclados entre s√≠ forman algo. As√≠ como en la qu√≠mica 2 √°tomos de hidr√≥geno y 2 de ox√≠geno formar√≠an agua, en esta metodolog√≠a un √°tomo de bot√≥n, otro de input y un √∫ltimo de label formar√≠a una mol√©cula de caja de b√∫squeda.

<div align="center">
    <img src="img/molecula.png" alt="Mol√©cula" width="400px" />
    <small><p>Mol√©cula.</p></small>
</div>

#### Organismos
Son el resultado de un conjunto de mol√©culas. Es decir, la caja de b√∫squeda podr√≠a ser parte del Header y junto a las dem√°s mol√©culas que se encuentren ah√≠ conformar√≠an el organismo del Header.

<div align="center">
    <img src="img/organismo.png" alt="Organismo" width="400px" />
    <small><p>Organismo.</p></small>
</div>


#### Templates
Son una especie de "Wireframe" donde ya se est√° dise√±ando la p√°gina y solo falta el contenido final (definitivo) como podr√≠a ser los artes finales, los colores, textos, etc.

<div align="center">
    <img src="img/templates.png" alt="Templates" width="400px" />
    <small><p>Templates.</p></small>
</div>


#### P√°ginas
Corresponden al sitio ya desarrollado en su totalidad con el contenido final.

<div align="center">
    <img src="img/pages.png" alt="P√°gina" width="400px" />
    <small><p>P√°gina.</p></small>
</div>

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

## Tipos de Nomenclaturas

### BEM: Block Element Modifier
Es la traducci√≥n de bloque, elemento y modificador. Es una nomenclatura para nombrar clases en CSS que consiste en dividir a las partes del contenido en bloques los cuales a su vez est√°n compuestos por elementos y si se da el caso de que un bloque o un elemento en particular posea alg√∫n rasgo diferente se le aplica un modificador. Se usa de la siguiente manera:

```css
.bloque{ ... }

.bloque__elemento{ ... }

.bloque--modificador{ ... }
```

Los bloques es lo primero que se declara. Es un componente (OOCSS) o un m√≥dulo (SMACSS). Es una pieza independiente de UI. Ex:

```html
<nav class="menu">
</nav>
```

Luego de haber declarado el bloque se procede a nombrar a los elementos que lo conforman anteponiendo el nombre del bloque seguidamente de doble gui√≥n bajo (_). Ex:

```html
<nav class="menu">
    <ul class="menu__list">
        <li class="menu__item">Item 1</li>
        <li class="menu__item">Item 2</li>
        <li class="menu__item">Item 3</li>
    </ul>
</nav>
```
Y en caso de necesitarse un modificador bien sea para un elemento o para el bloque se hace anteponiendo doble gui√≥n (--). Por ejemplo en este caso es un modificador para el bloque:

```html
<nav class="menu menu--principal">
    <ul class="menu__list">
        <li class="menu__item">Item 1</li>
        <li class="menu__item">Item 2</li>
        <li class="menu__item">Item 3</li>
    </ul>
</nav>
```

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

### SUIT CSS
Es un tipo de nomenclatura que comparado con BEM resulta muy similar; dado que lo que BEM llama Bloque en SUIT CSS es Componente, lo que BEM llama Elemento en SUIT CSS es Parte y el modificador es igual para ambos casos. Ex:

```css
.MyComponent{ ... }
.MyComponent.is-animating{ ... }
.MyComponent--modifier{ ... }
.MyComponent-part{ ... }
.MyComponent-anotherPart{ ... }
```

Aplicado ser√≠a:

```html
<nav class="Menu is-active">
    <ul class="Menu-list">
    </ul>
</nav>
```

N√≥tese que es muy similar a BEM solo que se usa *PascalCase* para el componente y *camelCase* para las partes del componente en caso de tener m√°s de 1 palabra y no se usa guiones bajos.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

## Contenido complementario

### Manejo de tipograf√≠as
Cuando se hace CSS una de las cosas que suele ocupar tiempo es la selecci√≥n de tama√±os de tipograf√≠as. Una buena forma de solucionarlo es teniendo previamente definido 6 tama√±os de fuente diferente disponibles para cualquier ocasi√≥n. Las cuales ser√≠an:

- **H1**: m√°s grande.
- **H2**: grande.
- **H3**: mediana.
- **p:** normal / tama√±o base.
- **H4**: peque√±a.
- **H5**: m√°s peque√±a.

Se podr√≠a implementar dichos estilos en clases tal como:

```css
.t1{ /*T√≠tulos de primer nivel o H1*/ }

.t2{ /*T√≠tulos de segundo nivel o H2*/ }

.t3{ /*T√≠tulos de tercer nivel o H3*/ }

.normal{ /*Tama√±o de fuente base*/ }

.s1{ /*T√≠tulos cuarto nivel o H4*/ }

.s2{ /*T√≠tulos quinto nivel o H5*/ }
```

La diferencia de tama√±o debe de partir con relaci√≥n al tama√±o base. Es decir a medida que crece el tama√±o se debe multiplicar por un factor de crecimiento con relaci√≥n a la de su tama√±o base y a medida que disminuye se divide, a esto se le conoce como "escala tipogr√°fica". Ex:

* Se debe tener un tama√±o base (tama√±o de fuente normal), en este caso ser√° el por defecto, es decir: 16px/1em.

* Se debe seleccionar un "ratio" por el cual se regir√° la escala a la hora de multiplicar/dividir. En este caso se usar√° la correspondiente al *Golden Ratio* = 1.618.

Con esto definido se procede a obtener el tama√±o de los m√°s grandes (multiplicaci√≥n):

- **H3** = Tama√±oBase(1em) * ratio(1.618) => 1.618em

- **H2** = H3 * ratio(1.618) => 2.618em

- **H1** = H2 * ratio(1.618) => 4.236em
    >Y as√≠ consecutivamente seg√∫n se necesite.

Para los tama√±os m√°s peque√±os (divisi√≥n):

- **H4** = tama√±oBase(1em) / ratio(1.618) => 0.618em

- **H5** = H4 / ratio(1.618) => 0.382em
    >Y as√≠ consecutivamente seg√∫n se necesite.


#### Notas
- N√≥tese como los tama√±os de fuente correspondientes a H4 y H5 (e inclusive si estuviera el H6) son m√°s peque√±os que los de un p√°rrafo normal.

- En resposive design se puede escalar o bajar un nivel (a ojo por ciento) el tama√±o de fuente seg√∫n se necesite. Ex:

    ```scss
    // SASS

    @mixin t1
    {
        font-size: $t3;

        @media screen and (min-width: 640px)
        {
            font-size: $t2;
        }
        @media screen and (min-width: 1024px)
        {
            font-size: $t1;
        }
    }
    ```
    >En dicho mixin se est√° estableciendo que el tama√±o de fuente del H1 en resoluciones menores a 640px sea el del H3 y para resoluciones mayor o igual a 640px sea la del H2, y cuando sea mayor o igual a 1024px cambie a su tama√±o original, es decir, la del H1.

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>

## Link de inter√©s

- [Guia de CSS Tricks para Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)
- [Documentaci√≥n oficial Flexbox](https://www.w3.org/TR/css-flexbox/)
- [Interactivo de flexbox](https://codepen.io/jonmircha/pen/aWWbre)
- [Juego: Flexbox Defense](https://www.flexboxdefense.com)
- [Juego: Flexbox Froggy](https://www.flexboxfroggy.com)
- [15 Reasons Why a Grid based approach will improve your designs](https://designschool.canva.com/blog/grid-design/)
- [The Grid System: Building a solid design layout](https://www.interaction-design.org/literature/article/)
- [La evoluci√≥n de la web](https://www.evolutionoftheweb.com)
- [960 Grid System](https://960.gs)
- [CSS reference](https://cssreference.io)
- [A complete guide to CSS Grid layout](https://chris.house/blog/a-complete-guide-css-grid-layout/)
- [Learn CSS Grid](https://learncssgrid.com)
- [Grid W3C](https://www.w3.org/TR/css3-grid-layout/)
- [Ejercicios interactivos de Grid](https://codepen.io/collection/DgwjNL/)
- [Juego: Grid Garden](https://cssgridgarden.com)
- [Test para Cross Browser](https://www.browserstack.com)
- [Conferencia de componentes modulares by Nicole Sullivan](https://vimeo.com/72759139)
- [Grafico de especificidad de CSS](https://jonassebastianohlsson.com/specificity-graph/)
- [Modular Scale (Escala tipografica)](https://www.modularscale.com)
- [Type-scale (Escala tipografica)](https://www.type-scale.com)
- [CSS Clip-path maker](https://www.bennettfeely.com/)
- [Videos para background](https://www.coverr.co)

<div align="right">
    <small>
        <a href="#tabla-de-contenido">
            ü°° volver al inicio
        </a>
    </small>
</div>